initSidebarItems({"enum":[["JSEvaluateErr","The errors which might be returned from cx.evaluate(\"code\")"],["JSStringContents",""]],"fn":[["finalize_jsobject_with_native_data",""],["jsclass_global_flags_with_slots",""],["jsclass_has_reserved_slots",""],["jscontext_called_from_js",""],["jsmanaged_called_from_js",""],["jsstring_called_from_js",""],["null_function",""],["null_property",""],["null_wrapper",""],["trace_jsobject_with_native_data",""]],"struct":[["BOUND","A compartment name that remembers the lifetime it was bound for."],["DefaultInitializer","A default class."],["Entered","A context state that has entered compartment `C` via an object with lifetime `'a` and global type `T`. The previous context state was `S`."],["FromJS","A context state for callbacks from JS,"],["Initialized","A context state in an initialized compartment `C` with lifetime `'a` and global type `T`."],["Initializing","A context state in the middTle of initializing a compartment `C` with lifetime `'a` and global type `T`."],["JSContext","The type for JS contexts whose current state is `S`."],["JSManaged","The type of JS-managed data in a JS compartment `C`, with lifetime `'a` and type `T`."],["JSPinnedRoot","A stack allocated root that has been pinned, so the backing store can't move."],["JSPinnedRoots","A doubly linked list with all the pinned roots."],["JSRoot","A stack allocated root containing data of type `T` with lifetime `'a`."],["JSString","The type of JS-managed strings in the same zone as compartment `C`, with lifetime `a`. Rust is much happier with flat string representations, so we flatten strings when they come into Rust."],["JSTracer",""],["Owned","A context state for JS contexts owned by Rust."],["OwnedJSRuntime","A JS runtime owned by Rust"],["SOMEWHERE","A wildcard compartment name."],["Snapshotted","A context state in snapshotted compartment in underlying state `S`, which guarantees that no GC will happen during the lifetime `'a`."],["UNSAFE","An unsafe compartment name, which we only give access to via unsafe code."]],"trait":[["CanAccess","A marker trait for JS contexts that can access native state"],["CanAlloc","A marker trait for JS contexts that can (de)allocate objects"],["CanCreateCompartments","A marker trait for JS contexts that can create new compartments."],["CanExtend","A marker trait for JS contexts that can extend the lifetime of objects"],["Compartment","A marker trait for JS compartments. We mark it as `Copy` so that anything that uses `[#derive{Copy)]` will be copyable. Ditto `Eq` and `Hash`."],["HasJSClass","A trait for a Rust class."],["InCompartment","A marker trait for JS contexts in compartment `C`"],["IsEntered","A marker trait for JS contexts that have been entered"],["IsInitialized","A marker trait for JS contexts that have initialized a global"],["IsInitializing","A marker trait for JS contexts that are in the middle of initializing"],["JSInitializable","A trait for Rust data which can be reflected"],["JSInitializer","Initialize JS data"],["JSRootable","Data which can be rooted."],["JSTraceable","A trait for Rust data that can be traced."],["JSTransplantable","Data which can be transplanted into compartment C."]]});