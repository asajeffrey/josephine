<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `josephine` crate.">
    <meta name="keywords" content="rust, rustlang, rust-lang, josephine">

    <title>josephine - Rust</title>

    <link rel="stylesheet" type="text/css" href="../normalize.css">
    <link rel="stylesheet" type="text/css" href="../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../main.css">
    

    
    
</head>
<body class="rustdoc mod">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        <p class='location'>Crate josephine</p><div class="block items"><ul><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'josephine', ty: 'mod', relpath: '../'};</script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content">
<h1 class='fqn'><span class='in-band'>Crate <a class="mod" href=''>josephine</a></span><span class='out-of-band'><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a class='srclink' href='../src/josephine/lib.rs.html#1-1896' title='goto source code'>[src]</a></span></h1>
<div class='docblock'><p>A library which uses JavaScript to safely manage the lifetimes of Rust data.</p>

<p>(
<a href="https://github.com/asajeffrey/josephine">Repo</a> |
<a href="https://travis-ci.org/asajeffrey/josephine">CI</a>
)</p>

<p>This library allows Rust data to be attached to JavaScript objects:
the lifetime of the Rust data is then the same as the JS object it is attached to.
Since JS is garbage collected, it is safe to copy and discard references to
JS managed data, and allows examples like doubly-linked lists which would
otherwise require reference counting. Reference counting requires dynamic checks,
for example getting mutable access to reference-counted data panics if the reference
count is more than 1.</p>

<p>The goals are:</p>

<ol>
<li>Use JS to manage the lifetime of Rust data.</li>
<li>Allow references to JS managed data to be freely copied and discarded, relying on
the garbage collector for safety.</li>
<li>Maintain Rust memory safety (for example no mutable aliasing),
without requiring additional static analysis such as a lint.</li>
<li>Allow mutable and immutable access to Rust data via JS managed references, so
we do not need to rely on interior mutability.</li>
<li>Provide a rooting API to ensure that JS managed data is not garbage collected
while it is being used.</li>
</ol>

<p>To support safe access to JS managed data, the API uses a <em>JS context</em>, which
is used as an access token to allow JS managed data to be accessed, allocated
or deallocated. Mutable access to JS managed data requires mutable access to the
JS context, which is how the API achieves memory safety even though JS managed
references can be copied and discarded freely.</p>

<p>JS managed memory is split into <em>compartments</em>, which are
separately garbage collected, so the garbage collector can avoid
scanning the entire heap. The API statically tracks compartments, to
ensure that there are no direct references between compartments.</p>

<p>The API is implemented as bindings to the SpiderMonkey JS engine,
from which it borrows the garbage collector and the notions of compartment
and JS context. The API allows calling into JavaScript
from Rust, and calling back into Rust from JavaScript. These bindings are unsafe,
and are intended for use by a trusted bindings generator.</p>

<h1 id='js-managed-data' class='section-header'><a href='#js-managed-data'>JS-managed data</a></h1>
<p>Rust data can be given to JS to manage, and then accessed,
using the JS context. The JS context is passed as a variable of type <code>JSContext&lt;S&gt;</code>,
where the type parameter <code>S</code> is used to track the state of the context.
The context comes with the permissions it grants, such as <code>CanAlloc</code>
and <code>CanAccess</code>. These permissions are modelled as traits, for example
a context in state <code>S</code> can allocate memory when <code>S: CanAlloc</code>.</p>

<p>JS managed memory is split into compartments. Each JS context has a notion of
the current compartment, which is part of the state. A JS context in compartment
<code>C</code> has type <code>JSCompartment&lt;S&gt;</code> where <code>S: InCompartment&lt;C&gt;</code> and <code>C: Compartment</code>.
A reference to JS managed data in compartment <code>C</code>, where the Rust data being
managed by JS has type <code>T</code>, is given type <code>JSManaged&lt;C, T&gt;</code>.</p>

<p>For example, we can give JS a Rust string to manage in compartment
<code>C</code>:</p>

<pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">example</span><span class="op">&lt;</span><span class="ident">C</span>, <span class="ident">S</span><span class="op">&gt;</span>(<span class="ident">cx</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">JSContext</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span>) <span class="kw">where</span>
    <span class="ident">S</span>: <span class="ident">CanAlloc</span> <span class="op">+</span> <span class="ident">InCompartment</span><span class="op">&lt;</span><span class="ident">C</span><span class="op">&gt;</span>,
    <span class="ident">C</span>: <span class="ident">Compartment</span>,
{
    <span class="kw">let</span> <span class="ident">x</span>: <span class="ident">JSManaged</span><span class="op">&lt;</span><span class="ident">C</span>, <span class="ident">String</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">cx</span>.<span class="ident">manage</span>(<span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;hello&quot;</span>));
}</pre>

<p>and then access it:</p>

<pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">example</span><span class="op">&lt;</span><span class="ident">C</span>, <span class="ident">S</span><span class="op">&gt;</span>(<span class="ident">cx</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">JSContext</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span>, <span class="ident">x</span>: <span class="ident">JSManaged</span><span class="op">&lt;</span><span class="ident">C</span>, <span class="ident">String</span><span class="op">&gt;</span>) <span class="kw">where</span>
    <span class="ident">S</span>: <span class="ident">CanAccess</span>,
    <span class="ident">C</span>: <span class="ident">Compartment</span>,
{
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{} world&quot;</span>, <span class="ident">x</span>.<span class="ident">borrow</span>(<span class="ident">cx</span>));
}</pre>

<h1 id='lifetimes-of-js-managed-data' class='section-header'><a href='#lifetimes-of-js-managed-data'>Lifetimes of JS-managed data</a></h1>
<p>Unfortunately, combining these two examples is not memory-safe, due to
garbage collection:</p>

<div class='information'><div class='tooltip ignore'>⚠<span class='tooltiptext'>Be careful when using this code, it's not being tested!</span></div></div><pre class="rust rust-example-rendered ignore">
<span class="kw">fn</span> <span class="ident">unsafe_example</span><span class="op">&lt;</span><span class="ident">C</span>, <span class="ident">S</span><span class="op">&gt;</span>(<span class="ident">cx</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">JSContext</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span>) <span class="kw">where</span>
    <span class="ident">S</span>: <span class="ident">CanAlloc</span> <span class="op">+</span> <span class="ident">CanAccess</span> <span class="op">+</span> <span class="ident">InCompartment</span><span class="op">&lt;</span><span class="ident">C</span><span class="op">&gt;</span>,
    <span class="ident">C</span>: <span class="ident">Compartment</span>,
{
    <span class="kw">let</span> <span class="ident">x</span>: <span class="ident">JSManaged</span><span class="op">&lt;</span><span class="ident">C</span>, <span class="ident">String</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">cx</span>.<span class="ident">manage</span>(<span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;hello&quot;</span>));
    <span class="comment">// Imagine something triggers GC here</span>
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{} world&quot;</span>, <span class="ident">x</span>.<span class="ident">borrow</span>(<span class="ident">cx</span>));
}</pre>

<p>This example is not safe, as there is nothing keeping <code>x</code> alive in JS,
so if garbage collection is triggered, then <code>x</code> will be reclaimed
which will drop the Rust data, and so the call to <code>x.borrow(cx)</code> will be a use-after-free.</p>

<p>This example is not memory-safe, and fortunately fails to typecheck:</p>

<pre><code class="language-text">    error[E0502]: cannot borrow `*cx` as immutable because it is also borrowed as mutable
  --&gt; src/lib.rs:10:35
   |
8  |     let x: JSManaged&lt;C, String&gt; = cx.manage(String::from(&quot;hello&quot;));
   |                                   -- mutable borrow occurs here
9  |     // Imagine something triggers GC here
10 |     println!(&quot;{} world&quot;, x.borrow(cx));
   |                                   ^^ immutable borrow occurs here
11 | }
   | - mutable borrow ends here
</code></pre>

<p>To see why this example fails to typecheck, we can introduce explicit lifetimes:</p>

<div class='information'><div class='tooltip ignore'>⚠<span class='tooltiptext'>Be careful when using this code, it's not being tested!</span></div></div><pre class="rust rust-example-rendered ignore">
<span class="kw">fn</span> <span class="ident">unsafe_example</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">C</span>, <span class="ident">S</span><span class="op">&gt;</span>(<span class="ident">cx</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="kw-2">mut</span> <span class="ident">JSContext</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span>) <span class="kw">where</span>
    <span class="ident">S</span>: <span class="ident">CanAlloc</span> <span class="op">+</span> <span class="ident">CanAccess</span> <span class="op">+</span> <span class="ident">InCompartment</span><span class="op">&lt;</span><span class="ident">C</span><span class="op">&gt;</span>,
    <span class="ident">C</span>: <span class="ident">Compartment</span>,
{
    <span class="comment">// x has type JSManaged&lt;&#39;b, C, String&gt;</span>
    <span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">cx</span>.<span class="ident">manage</span>(<span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;hello&quot;</span>));
    <span class="comment">// Imagine something triggers GC here</span>
    <span class="comment">// x_ref has type &amp;&#39;c String</span>
    <span class="kw">let</span> <span class="ident">x_ref</span> <span class="op">=</span> <span class="ident">x</span>.<span class="ident">borrow</span>(<span class="ident">cx</span>);
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{} world&quot;</span>, <span class="ident">x_ref</span>);
}</pre>

<p>We can now see why this fails to typecheck: since <code>cx</code> is borrowed mutably at type
<code>&amp;&#39;b mut JSContext&lt;S&gt;</code>, then immutably at type <code>&amp;&#39;c mut JSContext&lt;S&gt;</code> these lifetimes
cannot overlap, but the call to <code>x.borrow(cx)</code> requires them to overlap. These contradicting
constraints cause the example to fail to compile.</p>

<h1 id='rooting' class='section-header'><a href='#rooting'>Rooting</a></h1>
<p>To fix this example, we need to make sure that <code>x</code> lives long enough. One way to do this is
to root <code>x</code>, so that it will not be garbage collected.</p>

<pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">example</span><span class="op">&lt;</span><span class="ident">C</span>, <span class="ident">S</span><span class="op">&gt;</span>(<span class="ident">cx</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">JSContext</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span>) <span class="kw">where</span>
    <span class="ident">S</span>: <span class="ident">CanAlloc</span> <span class="op">+</span> <span class="ident">CanAccess</span> <span class="op">+</span> <span class="ident">InCompartment</span><span class="op">&lt;</span><span class="ident">C</span><span class="op">&gt;</span>,
    <span class="ident">C</span>: <span class="ident">Compartment</span>,
{
    <span class="comment">// Declare a root which will be used to keep x alive during its lifetime</span>
    <span class="kw">let</span> <span class="kw-2">ref</span> <span class="kw-2">mut</span> <span class="ident">root</span> <span class="op">=</span> <span class="ident">cx</span>.<span class="ident">new_root</span>();
    <span class="comment">// Store a reference to x in the root</span>
    <span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">cx</span>.<span class="ident">manage</span>(<span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;hello&quot;</span>)).<span class="ident">in_root</span>(<span class="ident">root</span>);
    <span class="comment">// This is what is keeping x alive ------^</span>
    <span class="comment">// Imagine something triggers GC here</span>
    <span class="comment">// The root ensures that x survives GC, so is safe to use</span>
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{} world&quot;</span>, <span class="ident">x</span>.<span class="ident">borrow</span>(<span class="ident">cx</span>));
}</pre>

<p>To see why this example now typechecks, we again introduce explicit lifetimes:</p>

<pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">example</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">C</span>, <span class="ident">S</span><span class="op">&gt;</span>(<span class="ident">cx</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="kw-2">mut</span> <span class="ident">JSContext</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span>) <span class="kw">where</span>
    <span class="ident">S</span>: <span class="ident">CanAlloc</span> <span class="op">+</span> <span class="ident">CanAccess</span> <span class="op">+</span> <span class="ident">InCompartment</span><span class="op">&lt;</span><span class="ident">C</span><span class="op">&gt;</span>,
    <span class="ident">C</span>: <span class="ident">Compartment</span>,
{
    <span class="comment">// root has type JSRoot&lt;&#39;b, String&gt;</span>
    <span class="kw">let</span> <span class="kw-2">ref</span> <span class="kw-2">mut</span> <span class="ident">root</span> <span class="op">=</span> <span class="ident">cx</span>.<span class="ident">new_root</span>();
    <span class="comment">// x has type JSManaged&lt;&#39;b, C, String&gt;</span>
    <span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> {
        <span class="comment">// x_unrooted has type JSManaged&lt;&#39;d, C, String&gt;</span>
        <span class="kw">let</span> <span class="ident">x_unrooted</span> <span class="op">=</span> <span class="ident">cx</span>.<span class="ident">manage</span>(<span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;hello&quot;</span>));
        <span class="comment">// By rooting it, its lifetime changes from &#39;d to &#39;b (the lifetime of the root)</span>
        <span class="ident">x_unrooted</span>.<span class="ident">in_root</span>(<span class="ident">root</span>)
    };
    <span class="comment">// Imagine something triggers GC here</span>
    <span class="comment">// x_ref has type &amp;&#39;c String</span>
    <span class="kw">let</span> <span class="ident">x_ref</span> <span class="op">=</span> <span class="ident">x</span>.<span class="ident">borrow</span>(<span class="ident">cx</span>);
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{} world&quot;</span>, <span class="ident">x_ref</span>);
}</pre>

<p>The example typechecks because the 
constraints are that <code>&#39;b</code> overlaps with <code>&#39;c</code> and <code>&#39;d</code>, and that
<code>&#39;c</code> and <code>&#39;d</code> don&#39;t overlap. These constraints are satisfiable, so the
example typechecks.</p>

<h1 id='mutating-js-managed-data' class='section-header'><a href='#mutating-js-managed-data'>Mutating JS-managed data</a></h1>
<p>JS managed data can be accessed mutably as well as immutably.
This is safe because mutably accessing JS manage data requires
mutably borrowing the JS context, so there cannot be two simultaneous
mutable accesses.</p>

<pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">example</span><span class="op">&lt;</span><span class="ident">C</span>, <span class="ident">S</span><span class="op">&gt;</span>(<span class="ident">cx</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">JSContext</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span>, <span class="ident">x</span>: <span class="ident">JSManaged</span><span class="op">&lt;</span><span class="ident">C</span>, <span class="ident">String</span><span class="op">&gt;</span>) <span class="kw">where</span>
    <span class="ident">S</span>: <span class="ident">CanAccess</span>,
    <span class="ident">C</span>: <span class="ident">Compartment</span>,
{
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{} world&quot;</span>, <span class="ident">x</span>.<span class="ident">borrow</span>(<span class="ident">cx</span>));
    <span class="kw-2">*</span><span class="ident">x</span>.<span class="ident">borrow_mut</span>(<span class="ident">cx</span>) <span class="op">=</span> <span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;hi&quot;</span>);
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{} world&quot;</span>, <span class="ident">x</span>.<span class="ident">borrow</span>(<span class="ident">cx</span>));
}</pre>

<p>An attempt to mutably access JS managed data more than once simultaneously
results in an error from the borrow-checker, for example:</p>

<div class='information'><div class='tooltip ignore'>⚠<span class='tooltiptext'>Be careful when using this code, it's not being tested!</span></div></div><pre class="rust rust-example-rendered ignore">
<span class="kw">fn</span> <span class="ident">unsafe_example</span><span class="op">&lt;</span><span class="ident">C</span>, <span class="ident">S</span><span class="op">&gt;</span>(<span class="ident">cx</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">JSContext</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span>, <span class="ident">x</span>: <span class="ident">JSManaged</span><span class="op">&lt;</span><span class="ident">C</span>, <span class="ident">String</span><span class="op">&gt;</span>, <span class="ident">y</span>: <span class="ident">JSManaged</span><span class="op">&lt;</span><span class="ident">C</span>, <span class="ident">String</span><span class="op">&gt;</span>) <span class="kw">where</span>
    <span class="ident">S</span>: <span class="ident">CanAccess</span>,
    <span class="ident">C</span>: <span class="ident">Compartment</span>,
{
    <span class="ident">mem</span>::<span class="ident">swap</span>(<span class="ident">x</span>.<span class="ident">borrow_mut</span>(<span class="ident">cx</span>), <span class="ident">y</span>.<span class="ident">borrow_mut</span>(<span class="ident">cx</span>));
}</pre>

<pre><code class="language-text">    error[E0499]: cannot borrow `*cx` as mutable more than once at a time
 --&gt; src/lib.rs:8:46
  |
8 |     mem::swap(x.borrow_mut(cx), y.borrow_mut(cx));
  |                            --                ^^ - first borrow ends here
  |                            |                 |
  |                            |                 second mutable borrow occurs here
  |                            first mutable borrow occurs here
</code></pre>

<h1 id='snapshots' class='section-header'><a href='#snapshots'>Snapshots</a></h1>
<p>Some cases of building JS managed data require rooting, but in some cases
the rooting can be avoided, since the program does nothing to trigger
garbage collection. In this case, we can snapshot the JS context after
performing allocation. The snapshot supports accessing JS managed data,
but does not support any calls that might trigger garbage collection.
As a result, we know that any data which is live at the beginning of
the snapshot is also live at the end.</p>

<pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">example</span><span class="op">&lt;</span><span class="ident">C</span>, <span class="ident">S</span><span class="op">&gt;</span>(<span class="ident">cx</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">JSContext</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span>) <span class="kw">where</span>
    <span class="ident">S</span>: <span class="ident">CanAlloc</span> <span class="op">+</span> <span class="ident">CanAccess</span> <span class="op">+</span> <span class="ident">InCompartment</span><span class="op">&lt;</span><span class="ident">C</span><span class="op">&gt;</span>,
    <span class="ident">C</span>: <span class="ident">Compartment</span>,
{
    <span class="kw">let</span> (<span class="kw-2">ref</span> <span class="ident">cx</span>, <span class="ident">x</span>) <span class="op">=</span> <span class="ident">cx</span>.<span class="ident">snapshot_manage</span>(<span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;hello&quot;</span>));
    <span class="comment">// Since the context is snapshotted it can&#39;t trigger GC</span>
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{} world&quot;</span>, <span class="ident">x</span>.<span class="ident">borrow</span>(<span class="ident">cx</span>));
}</pre>

<p>A program which tries to use a function which might trigger GC will
not typecheck, as the snapshotted JS context state does not support
the appropriate traits. For example:</p>

<div class='information'><div class='tooltip ignore'>⚠<span class='tooltiptext'>Be careful when using this code, it's not being tested!</span></div></div><pre class="rust rust-example-rendered ignore">
<span class="kw">fn</span> <span class="ident">unsafe_example</span><span class="op">&lt;</span><span class="ident">C</span>, <span class="ident">S</span><span class="op">&gt;</span>(<span class="ident">cx</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">JSContext</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span>) <span class="kw">where</span>
    <span class="ident">S</span>: <span class="ident">CanAlloc</span> <span class="op">+</span> <span class="ident">CanAccess</span> <span class="op">+</span> <span class="ident">InCompartment</span><span class="op">&lt;</span><span class="ident">C</span><span class="op">&gt;</span>,
    <span class="ident">C</span>: <span class="ident">Compartment</span>,
{
    <span class="kw">let</span> (<span class="kw-2">ref</span> <span class="kw-2">mut</span> <span class="ident">cx</span>, <span class="ident">x</span>) <span class="op">=</span> <span class="ident">cx</span>.<span class="ident">snapshot_manage</span>(<span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;hello&quot;</span>));
    <span class="ident">cx</span>.<span class="ident">gc</span>();
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{} world&quot;</span>, <span class="ident">x</span>.<span class="ident">borrow</span>(<span class="ident">cx</span>));
}</pre>

<p>In this program, the call to <code>cx.gc()</code> requires the state
to support <code>CanAlloc&lt;C&gt;</code>, which is not allowed by the snapshotted state.</p>

<pre><code class="language-text">    error[E0277]: the trait bound `josephine::Snapshotted&lt;&#39;_, S&gt;: josephine::CanAlloc` is not satisfied
 --&gt; src/lib.rs:9:8
  |
9 |     cx.gc();
  |        ^^ the trait `josephine::CanAlloc` is not implemented for `josephine::Snapshotted&lt;&#39;_, S&gt;`
</code></pre>

<h1 id='working-with-compartments' class='section-header'><a href='#working-with-compartments'>Working with compartments</a></h1>
<p>To enter the compartment of a JS managed object, you can use <code>cx.enter_known_compartment(managed)</code>.
This returns a context whose current compartment is that of the JS managed objecct.</p>

<pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">example</span><span class="op">&lt;</span><span class="ident">C</span>, <span class="ident">S</span><span class="op">&gt;</span>(<span class="ident">cx</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">JSContext</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span>, <span class="ident">x</span>: <span class="ident">JSManaged</span><span class="op">&lt;</span><span class="ident">C</span>, <span class="ident">String</span><span class="op">&gt;</span>) <span class="kw">where</span>
    <span class="ident">S</span>: <span class="ident">CanAccess</span> <span class="op">+</span> <span class="ident">CanAlloc</span>,
    <span class="ident">C</span>: <span class="ident">Compartment</span>,
{
    <span class="comment">// We can&#39;t allocate data without entering the comartment.</span>
    <span class="comment">// Commenting out the next line gives an error</span>
    <span class="comment">// the trait `josephine::InCompartment&lt;_&gt;` is not implemented for `S`.</span>
    <span class="kw">let</span> <span class="kw-2">ref</span> <span class="kw-2">mut</span> <span class="ident">cx</span> <span class="op">=</span> <span class="ident">cx</span>.<span class="ident">enter_known_compartment</span>(<span class="ident">x</span>);
    <span class="kw">let</span> <span class="kw-2">ref</span> <span class="kw-2">mut</span> <span class="ident">root</span> <span class="op">=</span> <span class="ident">cx</span>.<span class="ident">new_root</span>();
    <span class="kw">let</span> <span class="ident">y</span> <span class="op">=</span> <span class="ident">cx</span>.<span class="ident">manage</span>(<span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;world&quot;</span>)).<span class="ident">in_root</span>(<span class="ident">root</span>);
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Hello, {}.&quot;</span>, <span class="ident">y</span>.<span class="ident">borrow</span>(<span class="ident">cx</span>));
}</pre>

<p>Working with named compartmens is fine when there is a fixed number of them, but not when
the number of compartments is unbounded. For example, the type <code>Vec&lt;JSManaged&lt;C, T&gt;&gt;</code> contains
a vector of managed objects, all in the same compartment, but sometimes you need a vector of
objects in different compartments. This is what <em>wildcards</em> are for (borrowed from
<a href="https://docs.oracle.com/javase/tutorial/java/generics/wildcards.html">Java wildcards</a>
which solve a similar problem).</p>

<p>The wildcard compartment is called <code>SOMEWHERE</code>, and <code>JSManaged&lt;SOMEWHERE, T&gt;</code> refers
to JS managed data whose compartment is unknown. For example <code>Vec&lt;JSManaged&lt;SOMEWHERE, T&gt;&gt;</code>
contains a vector of managed objects, which may all be in different compartments.</p>

<p>To create a <code>JSManaged&lt;SOMEWHERE, T&gt;</code>, we use <code>managed.forget_compartment()</code>.</p>

<pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">example</span><span class="op">&lt;</span><span class="ident">C</span>, <span class="ident">S</span><span class="op">&gt;</span>(<span class="ident">cx</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">JSContext</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="ident">JSManaged</span><span class="op">&lt;</span><span class="ident">SOMEWHERE</span>, <span class="ident">String</span><span class="op">&gt;</span> <span class="kw">where</span>
    <span class="ident">S</span>: <span class="ident">CanAlloc</span> <span class="op">+</span> <span class="ident">InCompartment</span><span class="op">&lt;</span><span class="ident">C</span><span class="op">&gt;</span>,
    <span class="ident">C</span>: <span class="ident">Compartment</span>,
{
    <span class="ident">cx</span>.<span class="ident">manage</span>(<span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;hello&quot;</span>)).<span class="ident">forget_compartment</span>()
}</pre>

<p>To access data with a wildcard compartment, first enter the compartment
using <code>cx.enter_unknown_compartment(managed)</code>.</p>

<pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">example</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span>(<span class="ident">cx</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">JSContext</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span>, <span class="ident">x</span>: <span class="ident">JSManaged</span><span class="op">&lt;</span><span class="ident">SOMEWHERE</span>, <span class="ident">String</span><span class="op">&gt;</span>) <span class="kw">where</span>
    <span class="ident">S</span>: <span class="ident">CanAccess</span>,
{
    <span class="comment">// We can&#39;t access x without first entering its compartment.</span>
    <span class="comment">// Commenting out the next two lines gives an error</span>
    <span class="comment">// the trait `josephine::Compartment` is not implemented for `josephine::SOMEWHERE`.</span>
    <span class="kw">let</span> <span class="kw-2">ref</span> <span class="kw-2">mut</span> <span class="ident">cx</span> <span class="op">=</span> <span class="ident">cx</span>.<span class="ident">enter_unknown_compartment</span>(<span class="ident">x</span>);
    <span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">cx</span>.<span class="ident">entered</span>();
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Hello, {}.&quot;</span>, <span class="ident">x</span>.<span class="ident">borrow</span>(<span class="ident">cx</span>));
}</pre>

<p>Sometimes you need to check to see if some JS managed data is in the current compartment or not.
This is done with <code>managed.in_compartment(cx)</code>, which returns an <code>Option&lt;JSManaged&lt;C, T&gt;&gt;</code>
when the context&#39;s current compartment is <code>C</code>. The result is <code>Some(managed)</code> if <code>managed</code> was in
compartment <code>C</code>, and <code>None</code> if it was in a different compartment.</p>

<pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">example</span><span class="op">&lt;</span><span class="ident">S</span>, <span class="ident">C</span><span class="op">&gt;</span>(<span class="ident">cx</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">JSContext</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span>, <span class="ident">x</span>: <span class="ident">JSManaged</span><span class="op">&lt;</span><span class="ident">SOMEWHERE</span>, <span class="ident">String</span><span class="op">&gt;</span>) <span class="kw">where</span>
    <span class="ident">S</span>: <span class="ident">CanAccess</span> <span class="op">+</span> <span class="ident">InCompartment</span><span class="op">&lt;</span><span class="ident">C</span><span class="op">&gt;</span>,
    <span class="ident">C</span>: <span class="ident">Compartment</span>,
{
    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">x</span>) <span class="op">=</span> <span class="ident">x</span>.<span class="ident">in_compartment</span>(<span class="ident">cx</span>) {
        <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Hello, {}.&quot;</span>, <span class="ident">x</span>.<span class="ident">borrow</span>(<span class="ident">cx</span>));
    }
}</pre>

<h1 id='user-defined-types' class='section-header'><a href='#user-defined-types'>User-defined types</a></h1>
<p>There are more types to manage than just <code>String</code>!</p>

<p>To be managed by <code>JSManageable</code>, a type should implement the following traits:</p>

<ul>
<li><code>JSTraceable</code>: values of the type can be <em>traced</em>, that is can tell the garbage
collector which objects are reachable from them.</li>
<li><code>JSRootable</code>: values of the type have their lifetime managed by JS.</li>
<li><code>JSTransplantable</code>: values of the type have their compartment managed by JS.</li>
<li><code>JSInitializable</code>: this type knows how to initialize a JS object which is used
to manage its lifetime.</li>
</ul>

<p>Each of these traits can be derived. The fields of a <code>JSTraceable</code> type should be
<code>JSTraceable</code>, and similarly for <code>JSRootable</code> and <code>JSTransplantable</code>. This requirement
is <em>not</em> true for <code>JSInitializable</code>.</p>

<p>A typical use is to define two types: the <em>native</em> type <code>NativeThing</code>
and then the <em>managed</em> type <code>Thing&lt;&#39;a, C&gt;</code> which is just a <code>JSManaged&lt;&#39;a, C, NativeThing&gt;</code>.</p>

<pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">JSInitializable</span>, <span class="ident">JSTraceable</span>, <span class="ident">JSRootable</span>, <span class="ident">JSTransplantable</span>)]</span>
<span class="kw">struct</span> <span class="ident">NativeName</span> { <span class="ident">name</span>: <span class="ident">String</span> }

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Clone</span>, <span class="ident">Copy</span>, <span class="ident">Debug</span>, <span class="ident">Eq</span>, <span class="ident">PartialEq</span>, <span class="ident">JSInitializable</span>, <span class="ident">JSTraceable</span>, <span class="ident">JSRootable</span>, <span class="ident">JSTransplantable</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Name</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">C</span><span class="op">&gt;</span> (<span class="ident">JSManaged</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">C</span>, <span class="ident">NativeName</span><span class="op">&gt;</span>);

<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">C</span>:<span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">Name</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">C</span><span class="op">&gt;</span> {
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">new</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span>(<span class="ident">cx</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="kw-2">mut</span> <span class="ident">JSContext</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span>, <span class="ident">name</span>: <span class="kw-2">&amp;</span><span class="ident">str</span>) <span class="op">-&gt;</span> <span class="ident">Name</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">C</span><span class="op">&gt;</span> <span class="kw">where</span>
        <span class="ident">S</span>: <span class="ident">CanAlloc</span> <span class="op">+</span> <span class="ident">InCompartment</span><span class="op">&lt;</span><span class="ident">C</span><span class="op">&gt;</span>,
        <span class="ident">C</span>: <span class="ident">Compartment</span>,
    {
        <span class="ident">Name</span>(<span class="ident">cx</span>.<span class="ident">manage</span>(<span class="ident">NativeName</span> { <span class="ident">name</span>: <span class="ident">String</span>::<span class="ident">from</span>(<span class="ident">name</span>) }))
    }
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">name</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span>(<span class="self">self</span>, <span class="ident">cx</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">JSContext</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">str</span> <span class="kw">where</span>
        <span class="ident">S</span>: <span class="ident">CanAccess</span>,
        <span class="ident">C</span>: <span class="ident">Compartment</span>,
    {
        <span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="self">self</span>.<span class="number">0</span>.<span class="ident">borrow</span>(<span class="ident">cx</span>).<span class="ident">name</span>
    }
}

<span class="kw">let</span> <span class="kw-2">ref</span> <span class="kw-2">mut</span> <span class="ident">root</span> <span class="op">=</span> <span class="ident">cx</span>.<span class="ident">new_root</span>();
<span class="kw">let</span> <span class="ident">hello</span> <span class="op">=</span> <span class="ident">Name</span>::<span class="ident">new</span>(<span class="ident">cx</span>, <span class="string">&quot;hello&quot;</span>).<span class="ident">in_root</span>(<span class="ident">root</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">hello</span>.<span class="ident">name</span>(<span class="ident">cx</span>), <span class="string">&quot;hello&quot;</span>);</pre>

<p>Sometimes the native type will itself contain references to JS-managed data,
so will need to be parameterized on a lifetime and compartment.</p>

<pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">JSInitializable</span>, <span class="ident">JSTraceable</span>, <span class="ident">JSRootable</span>, <span class="ident">JSTransplantable</span>)]</span>
<span class="kw">struct</span> <span class="ident">NativeNames</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">C</span><span class="op">&gt;</span> { <span class="ident">names</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">Name</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">C</span><span class="op">&gt;&gt;</span> }

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Clone</span>, <span class="ident">Copy</span>, <span class="ident">Debug</span>, <span class="ident">JSInitializable</span>, <span class="ident">JSTraceable</span>, <span class="ident">JSRootable</span>, <span class="ident">JSTransplantable</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Names</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">C</span><span class="op">&gt;</span> (<span class="ident">JSManaged</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">C</span>, <span class="ident">NativeNames</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">C</span><span class="op">&gt;&gt;</span>);
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">C</span>:<span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">Names</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">C</span><span class="op">&gt;</span> {
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">new</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span>(<span class="ident">cx</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="kw-2">mut</span> <span class="ident">JSContext</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="ident">Names</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">C</span><span class="op">&gt;</span> <span class="kw">where</span>
        <span class="ident">S</span>: <span class="ident">CanAlloc</span> <span class="op">+</span> <span class="ident">InCompartment</span><span class="op">&lt;</span><span class="ident">C</span><span class="op">&gt;</span>,
        <span class="ident">C</span>: <span class="ident">Compartment</span>,
    {
        <span class="ident">Names</span>(<span class="ident">cx</span>.<span class="ident">manage</span>(<span class="ident">NativeNames</span> { <span class="ident">names</span>: <span class="macro">vec</span><span class="macro">!</span>[] }))
    }
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">push_str</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span>(<span class="self">self</span>, <span class="ident">cx</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="kw-2">mut</span> <span class="ident">JSContext</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span>, <span class="ident">name</span>: <span class="kw-2">&amp;</span><span class="ident">str</span>) <span class="kw">where</span>
        <span class="ident">S</span>: <span class="ident">CanAccess</span> <span class="op">+</span> <span class="ident">CanAlloc</span> <span class="op">+</span> <span class="ident">InCompartment</span><span class="op">&lt;</span><span class="ident">C</span><span class="op">&gt;</span>,
        <span class="ident">C</span>: <span class="ident">Compartment</span>,
    {
        <span class="kw">let</span> <span class="kw-2">ref</span> <span class="kw-2">mut</span> <span class="ident">root</span> <span class="op">=</span> <span class="ident">cx</span>.<span class="ident">new_root</span>();
        <span class="kw">let</span> <span class="ident">name</span> <span class="op">=</span> <span class="ident">Name</span>::<span class="ident">new</span>(<span class="ident">cx</span>, <span class="ident">name</span>).<span class="ident">in_root</span>(<span class="ident">root</span>);
        <span class="self">self</span>.<span class="number">0</span>.<span class="ident">borrow_mut</span>(<span class="ident">cx</span>).<span class="ident">names</span>.<span class="ident">push</span>(<span class="ident">name</span>);
    }
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">get</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span>(<span class="self">self</span>, <span class="ident">cx</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">JSContext</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span>, <span class="ident">index</span>: <span class="ident">usize</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">Name</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">C</span><span class="op">&gt;&gt;</span> <span class="kw">where</span>
        <span class="ident">S</span>: <span class="ident">CanAccess</span>,
        <span class="ident">C</span>: <span class="ident">Compartment</span>,
    {
        <span class="self">self</span>.<span class="number">0</span>.<span class="ident">borrow</span>(<span class="ident">cx</span>).<span class="ident">names</span>.<span class="ident">get</span>(<span class="ident">index</span>).<span class="ident">cloned</span>()
    }
}

<span class="kw">let</span> <span class="kw-2">ref</span> <span class="kw-2">mut</span> <span class="ident">root</span> <span class="op">=</span> <span class="ident">cx</span>.<span class="ident">new_root</span>();
<span class="kw">let</span> <span class="ident">hello_world</span> <span class="op">=</span> <span class="ident">Names</span>::<span class="ident">new</span>(<span class="ident">cx</span>).<span class="ident">in_root</span>(<span class="ident">root</span>);
<span class="ident">hello_world</span>.<span class="ident">push_str</span>(<span class="ident">cx</span>, <span class="string">&quot;hello&quot;</span>);
<span class="ident">hello_world</span>.<span class="ident">push_str</span>(<span class="ident">cx</span>, <span class="string">&quot;world&quot;</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">hello_world</span>.<span class="ident">get</span>(<span class="ident">cx</span>, <span class="number">0</span>).<span class="ident">map</span>(<span class="op">|</span><span class="ident">name</span><span class="op">|</span> <span class="ident">name</span>.<span class="ident">name</span>(<span class="ident">cx</span>)), <span class="prelude-val">Some</span>(<span class="string">&quot;hello&quot;</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">hello_world</span>.<span class="ident">get</span>(<span class="ident">cx</span>, <span class="number">1</span>).<span class="ident">map</span>(<span class="op">|</span><span class="ident">name</span><span class="op">|</span> <span class="ident">name</span>.<span class="ident">name</span>(<span class="ident">cx</span>)), <span class="prelude-val">Some</span>(<span class="string">&quot;world&quot;</span>));</pre>

<h1 id='globals' class='section-header'><a href='#globals'>Globals</a></h1>
<p>Each JS compartment has a special object called a <em>global</em>.
The compartment can be created using <code>cx.create_compartment()</code>,
and the global can be given native data to manage with <code>cx.global_manage(data)</code>.
The global can be accessed with <code>cx.global()</code>.</p>

<pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">JSInitializable</span>, <span class="ident">JSTraceable</span>, <span class="ident">JSRootable</span>, <span class="ident">JSTransplantable</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">NativeMyGlobal</span> { <span class="ident">name</span>: <span class="ident">String</span> }
<span class="kw">type</span> <span class="ident">MyGlobal</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">C</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">JSManaged</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">C</span>, <span class="ident">NativeMyGlobal</span><span class="op">&gt;</span>;

<span class="kw">fn</span> <span class="ident">example</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">S</span><span class="op">&gt;</span>(<span class="ident">cx</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="kw-2">mut</span> <span class="ident">JSContext</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="ident">MyGlobal</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">SOMEWHERE</span><span class="op">&gt;</span> <span class="kw">where</span>
   <span class="ident">S</span>: <span class="ident">CanCreateCompartments</span>,
{
   <span class="kw">let</span> <span class="ident">cx</span> <span class="op">=</span> <span class="ident">cx</span>.<span class="ident">create_compartment</span>();
   <span class="kw">let</span> <span class="ident">name</span> <span class="op">=</span> <span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;Alice&quot;</span>);
   <span class="kw">let</span> <span class="ident">cx</span> <span class="op">=</span> <span class="ident">cx</span>.<span class="ident">global_manage</span>(<span class="ident">NativeMyGlobal</span> { <span class="ident">name</span>: <span class="ident">name</span> });
   <span class="ident">cx</span>.<span class="ident">global</span>().<span class="ident">forget_compartment</span>()
}</pre>

<p>In some cases, the global contains some JS-managed data, which is why the initialization
is split into two steps: creating the compartment, and
providing the JS-managed data for the global, for example:</p>

<pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">JSInitializable</span>, <span class="ident">JSTraceable</span>, <span class="ident">JSRootable</span>, <span class="ident">JSTransplantable</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">NativeMyGlobal</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">C</span><span class="op">&gt;</span> { <span class="ident">name</span>: <span class="ident">JSManaged</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">C</span>, <span class="ident">String</span><span class="op">&gt;</span> }
<span class="kw">type</span> <span class="ident">MyGlobal</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">C</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">JSManaged</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">C</span>, <span class="ident">NativeMyGlobal</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">C</span><span class="op">&gt;&gt;</span>;

<span class="kw">fn</span> <span class="ident">example</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">S</span><span class="op">&gt;</span>(<span class="ident">cx</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="kw-2">mut</span> <span class="ident">JSContext</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="ident">MyGlobal</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">SOMEWHERE</span><span class="op">&gt;</span> <span class="kw">where</span>
   <span class="ident">S</span>: <span class="ident">CanCreateCompartments</span>,
{
   <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">cx</span> <span class="op">=</span> <span class="ident">cx</span>.<span class="ident">create_compartment</span>();
   <span class="kw">let</span> <span class="kw-2">ref</span> <span class="kw-2">mut</span> <span class="ident">root</span> <span class="op">=</span> <span class="ident">cx</span>.<span class="ident">new_root</span>();
   <span class="kw">let</span> <span class="ident">name</span> <span class="op">=</span> <span class="ident">cx</span>.<span class="ident">manage</span>(<span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;Alice&quot;</span>)).<span class="ident">in_root</span>(<span class="ident">root</span>);
   <span class="kw">let</span> <span class="kw-2">ref</span> <span class="ident">cx</span> <span class="op">=</span> <span class="ident">cx</span>.<span class="ident">global_manage</span>(<span class="ident">NativeMyGlobal</span> { <span class="ident">name</span>: <span class="ident">name</span> });
   <span class="ident">cx</span>.<span class="ident">global</span>().<span class="ident">forget_compartment</span>()
}</pre>

<h1 id='bootstrapping' class='section-header'><a href='#bootstrapping'>Bootstrapping</a></h1>
<p>The JSContext is built using <code>JSContext::new</code>.</p>

<pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">JSInitializable</span>, <span class="ident">JSTraceable</span>, <span class="ident">JSRootable</span>, <span class="ident">JSTransplantable</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">NativeMyGlobal</span> { <span class="ident">name</span>: <span class="ident">String</span> }
<span class="kw">type</span> <span class="ident">MyGlobal</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">C</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">JSManaged</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">C</span>, <span class="ident">NativeMyGlobal</span><span class="op">&gt;</span>;

<span class="kw">fn</span> <span class="ident">example</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">S</span><span class="op">&gt;</span>(<span class="ident">cx</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="kw-2">mut</span> <span class="ident">JSContext</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="ident">MyGlobal</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">SOMEWHERE</span><span class="op">&gt;</span> <span class="kw">where</span>
   <span class="ident">S</span>: <span class="ident">CanCreateCompartments</span>,
{
   <span class="kw">let</span> <span class="ident">cx</span> <span class="op">=</span> <span class="ident">cx</span>.<span class="ident">create_compartment</span>();
   <span class="kw">let</span> <span class="ident">name</span> <span class="op">=</span> <span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;Alice&quot;</span>);
   <span class="kw">let</span> <span class="ident">cx</span> <span class="op">=</span> <span class="ident">cx</span>.<span class="ident">global_manage</span>(<span class="ident">NativeMyGlobal</span> { <span class="ident">name</span>: <span class="ident">name</span> });
   <span class="ident">cx</span>.<span class="ident">global</span>().<span class="ident">forget_compartment</span>()
}
<span class="kw">fn</span> <span class="ident">main</span>() {
   <span class="kw">let</span> <span class="kw-2">ref</span> <span class="kw-2">mut</span> <span class="ident">cx</span> <span class="op">=</span> <span class="ident">JSContext</span>::<span class="ident">new</span>();
   <span class="ident">example</span>(<span class="ident">cx</span>);
}</pre>
</div><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.BOUND.html"
                                  title='struct josephine::BOUND'>BOUND</a></td>
                           <td class='docblock-short'>
                                <p>A compartment name that remembers the lifetime it was bound for.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.DefaultInitializer.html"
                                  title='struct josephine::DefaultInitializer'>DefaultInitializer</a></td>
                           <td class='docblock-short'>
                                <p>A default class.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.Entered.html"
                                  title='struct josephine::Entered'>Entered</a></td>
                           <td class='docblock-short'>
                                <p>A context state that has entered compartment <code>C</code> via an object with lifetime <code>&#39;a</code> and global type <code>T</code>.
The previous context state was <code>S</code>.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.FromJS.html"
                                  title='struct josephine::FromJS'>FromJS</a></td>
                           <td class='docblock-short'>
                                <p>A context state for callbacks from JS,</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.Initialized.html"
                                  title='struct josephine::Initialized'>Initialized</a></td>
                           <td class='docblock-short'>
                                <p>A context state in an initialized compartment <code>C</code> with lifetime <code>&#39;a</code> and global type <code>T</code>.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.Initializing.html"
                                  title='struct josephine::Initializing'>Initializing</a></td>
                           <td class='docblock-short'>
                                <p>A context state in the middTle of initializing a compartment <code>C</code> with lifetime <code>&#39;a</code> and global type <code>T</code>.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.JSContext.html"
                                  title='struct josephine::JSContext'>JSContext</a></td>
                           <td class='docblock-short'>
                                <p>The type for JS contexts whose current state is <code>S</code>.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.JSManaged.html"
                                  title='struct josephine::JSManaged'>JSManaged</a></td>
                           <td class='docblock-short'>
                                <p>The type of JS-managed data in a JS compartment <code>C</code>, with lifetime <code>&#39;a</code> and type <code>T</code>.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.JSPinnedRoot.html"
                                  title='struct josephine::JSPinnedRoot'>JSPinnedRoot</a></td>
                           <td class='docblock-short'>
                                <p>A stack allocated root that has been pinned, so the backing store can&#39;t move.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.JSPinnedRoots.html"
                                  title='struct josephine::JSPinnedRoots'>JSPinnedRoots</a></td>
                           <td class='docblock-short'>
                                <p>A doubly linked list with all the pinned roots.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.JSRoot.html"
                                  title='struct josephine::JSRoot'>JSRoot</a></td>
                           <td class='docblock-short'>
                                <p>A stack allocated root containing data of type <code>T</code> with lifetime <code>&#39;a</code>.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.JSString.html"
                                  title='struct josephine::JSString'>JSString</a></td>
                           <td class='docblock-short'>
                                <p>The type of JS-managed strings in the same zone as compartment <code>C</code>, with lifetime <code>a</code>.
Rust is much happier with flat string representations, so we flatten
strings when they come into Rust.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.JSTracer.html"
                                  title='struct josephine::JSTracer'>JSTracer</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.Owned.html"
                                  title='struct josephine::Owned'>Owned</a></td>
                           <td class='docblock-short'>
                                <p>A context state for JS contexts owned by Rust.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.OwnedJSRuntime.html"
                                  title='struct josephine::OwnedJSRuntime'>OwnedJSRuntime</a></td>
                           <td class='docblock-short'>
                                <p>A JS runtime owned by Rust</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.SOMEWHERE.html"
                                  title='struct josephine::SOMEWHERE'>SOMEWHERE</a></td>
                           <td class='docblock-short'>
                                <p>A wildcard compartment name.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.Snapshotted.html"
                                  title='struct josephine::Snapshotted'>Snapshotted</a></td>
                           <td class='docblock-short'>
                                <p>A context state in snapshotted compartment in underlying state <code>S</code>,
which guarantees that no GC will happen during the lifetime <code>&#39;a</code>.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.UNSAFE.html"
                                  title='struct josephine::UNSAFE'>UNSAFE</a></td>
                           <td class='docblock-short'>
                                <p>An unsafe compartment name, which we only give access to via unsafe code.</p>
                           </td>
                       </tr></table><h2 id='enums' class='section-header'><a href="#enums">Enums</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.JSEvaluateErr.html"
                                  title='enum josephine::JSEvaluateErr'>JSEvaluateErr</a></td>
                           <td class='docblock-short'>
                                <p>The errors which might be returned from cx.evaluate(&quot;code&quot;)</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.JSStringContents.html"
                                  title='enum josephine::JSStringContents'>JSStringContents</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr></table><h2 id='traits' class='section-header'><a href="#traits">Traits</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.CanAccess.html"
                                  title='trait josephine::CanAccess'>CanAccess</a></td>
                           <td class='docblock-short'>
                                <p>A marker trait for JS contexts that can access native state</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.CanAlloc.html"
                                  title='trait josephine::CanAlloc'>CanAlloc</a></td>
                           <td class='docblock-short'>
                                <p>A marker trait for JS contexts that can (de)allocate objects</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.CanCreateCompartments.html"
                                  title='trait josephine::CanCreateCompartments'>CanCreateCompartments</a></td>
                           <td class='docblock-short'>
                                <p>A marker trait for JS contexts that can create new compartments.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.CanExtend.html"
                                  title='trait josephine::CanExtend'>CanExtend</a></td>
                           <td class='docblock-short'>
                                <p>A marker trait for JS contexts that can extend the lifetime of objects</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.Compartment.html"
                                  title='trait josephine::Compartment'>Compartment</a></td>
                           <td class='docblock-short'>
                                <p>A marker trait for JS compartments.
We mark it as <code>Copy</code> so that anything that uses <code>[#derive{Copy)]</code> will be copyable.
Ditto <code>Eq</code> and <code>Hash</code>.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.HasJSClass.html"
                                  title='trait josephine::HasJSClass'>HasJSClass</a></td>
                           <td class='docblock-short'>
                                <p>A trait for a Rust class.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.InCompartment.html"
                                  title='trait josephine::InCompartment'>InCompartment</a></td>
                           <td class='docblock-short'>
                                <p>A marker trait for JS contexts in compartment <code>C</code></p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.IsEntered.html"
                                  title='trait josephine::IsEntered'>IsEntered</a></td>
                           <td class='docblock-short'>
                                <p>A marker trait for JS contexts that have been entered</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.IsInitialized.html"
                                  title='trait josephine::IsInitialized'>IsInitialized</a></td>
                           <td class='docblock-short'>
                                <p>A marker trait for JS contexts that have initialized a global</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.IsInitializing.html"
                                  title='trait josephine::IsInitializing'>IsInitializing</a></td>
                           <td class='docblock-short'>
                                <p>A marker trait for JS contexts that are in the middle of initializing</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.JSInitializable.html"
                                  title='trait josephine::JSInitializable'>JSInitializable</a></td>
                           <td class='docblock-short'>
                                <p>A trait for Rust data which can be reflected</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.JSInitializer.html"
                                  title='trait josephine::JSInitializer'>JSInitializer</a></td>
                           <td class='docblock-short'>
                                <p>Initialize JS data</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.JSRootable.html"
                                  title='trait josephine::JSRootable'>JSRootable</a></td>
                           <td class='docblock-short'>
                                <p>Data which can be rooted.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.JSTraceable.html"
                                  title='trait josephine::JSTraceable'>JSTraceable</a></td>
                           <td class='docblock-short'>
                                <p>A trait for Rust data that can be traced.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.JSTransplantable.html"
                                  title='trait josephine::JSTransplantable'>JSTransplantable</a></td>
                           <td class='docblock-short'>
                                <p>Data which can be transplanted into compartment C.</p>
                           </td>
                       </tr></table><h2 id='functions' class='section-header'><a href="#functions">Functions</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.finalize_jsobject_with_native_data.html"
                                  title='fn josephine::finalize_jsobject_with_native_data'>finalize_jsobject_with_native_data</a><a title='unsafe function' href='#'><sup>⚠</sup></a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.jsclass_global_flags_with_slots.html"
                                  title='fn josephine::jsclass_global_flags_with_slots'>jsclass_global_flags_with_slots</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.jsclass_has_reserved_slots.html"
                                  title='fn josephine::jsclass_has_reserved_slots'>jsclass_has_reserved_slots</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.jscontext_called_from_js.html"
                                  title='fn josephine::jscontext_called_from_js'>jscontext_called_from_js</a><a title='unsafe function' href='#'><sup>⚠</sup></a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.jsmanaged_called_from_js.html"
                                  title='fn josephine::jsmanaged_called_from_js'>jsmanaged_called_from_js</a><a title='unsafe function' href='#'><sup>⚠</sup></a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.jsstring_called_from_js.html"
                                  title='fn josephine::jsstring_called_from_js'>jsstring_called_from_js</a><a title='unsafe function' href='#'><sup>⚠</sup></a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.null_function.html"
                                  title='fn josephine::null_function'>null_function</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.null_property.html"
                                  title='fn josephine::null_property'>null_property</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.null_wrapper.html"
                                  title='fn josephine::null_wrapper'>null_wrapper</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.trace_jsobject_with_native_data.html"
                                  title='fn josephine::trace_jsobject_with_native_data'>trace_jsobject_with_native_data</a><a title='unsafe function' href='#'><sup>⚠</sup></a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr></table></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>↑</dt>
                    <dd>Move up in search results</dd>
                    <dt>↓</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                    <dt>+</dt>
                    <dd>Collapse/expand all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "josephine";
    </script>
    <script src="../main.js"></script>
    <script defer src="../search-index.js"></script>
</body>
</html>