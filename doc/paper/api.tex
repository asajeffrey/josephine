\section{The Josephine API}

There are two important concepts in Josephine's API: \emph{JS-managed} data,
and the JS \emph{context}. For readers familiar with the region-based
variant~\cite{l3-with-regions} of $L^3$~\cite{l3}, JS-managed data
corresponds to $L^3$ references, and JS contexts to $L^3$ capabilities.

\subsection{JS-managed data}

JS-managed data has the type $\JSManaged{\alpha, C, T}$, which represents
a reference to data whose lifetime is managed by JS, which:
\begin{itemize}

\item is guaranteed to live at least as long as $\alpha$,
\item is allocated in JS compartment $C$,
\item points to native data of type $T$.
  
\end{itemize}
This type is copyable, so not subject to the affine type discipline,
even though it can be used to gain mutable access to the native
data. We shall see later that this is safe for the same reason as
$L^3$: we are using the JS context as a capability, and it is not
copyable.

In examples, we make use of Rust's \emph{lifetime elision}~\cite{???},
and just write $\JSManaged{C,T}$ where the lifetime $\alpha$ can be
inferred.

In the simplest case, $T$ is a base type like $\STRING$, but in more complex
cases, $T$ might itself contain JS-managed data, for example a type of
cells in a doubly-linked list can be defined:
\begin{verbatim}
  type Cell<'a, C> = JSManaged<'a, C, NativeCell<'a, C>>;
\end{verbatim}
where:
\begin{verbatim}
  struct NativeCell<'a, C> {
    data: String,
    prev: Option<Cell<'a, C>>,
    next: Option<Cell<'a, C>>,
  }
\end{verbatim}
This pattern is a common idiom, in that there are two types:
\begin{itemize}
\item $\NativeCell{\alpha,C}$ containing the native representation
of a cell, including the prev and next
references, and
\item $\Cell{\alpha,C}$ containing a reference to a native cell,
whose lifetime is managed by JS.
\end{itemize}
These types are both parameterized by a lower bound $\alpha$ on the lifetime
of the cell, and the compartment $C$ that the cell lives in.

Doubly-linked lists are an interesting example of programming in Rust,
and indeed there is an introductory text \emph{Learning Rust With
  Entirely Too Many Linked Lists}~\cite{too-many-lists}, in which safe
implementations of doubly-linked lists require interior mutability
(and hence dynamic checks) and reference counting.

\subsection{The JS context}

By itself, JS-managed references are not much use: there has to be an
API for creating and dereferencing them: this is the role of the
JS \emph{context}, which acts as a capability for manipulating
JS-managed data.

There is only one JS context per thread (and JS contexts cannot be shared
or sent between threads) so unique access to the JS context implies unique
access to all JS-managed data. We can use this to give safe mutable access
to JS-managed data, since the JS context is a unique capability.

The JS context has a state, notably keeping track of the current
compartment, but also permissions such as ``allowed to create new
references'' or ``allowed to dereference''.  This state is tracked in
the type system using phantom types~\cite{phantom}, so the JS context
has type $\JSContext{S}$, where $S$ is the current state.

For example, a program to allocate a new JS-managed reference is:
\begin{verbatim}
  let x: JSManaged<C, String> = cx.manage(String::from("hello"));
\end{verbatim}
and a program to access a JS-managed reference is:
\begin{verbatim}
  let msg: &String = x.borrow(cx);
\end{verbatim}
These programs make use of the JS context \verb|cx|. In order for the
first example to typecheck:
\begin{itemize}

\item \verb|cx| must have type $\REFMUT{}\JSContext{S}$, where
\item $S$ (the state of the context) must have permission to allocate
  references in $C$, and
\item $C$ must be a compartment.

\end{itemize}
The second example is similar, except:
\begin{itemize}

\item we do not need mutable access to the context, and
\item $S$ need the permission to access compartment $C$.

\end{itemize}
Fortunately, Rust has a \emph{trait} system (similar to Haskell's
class system), which allows us to express these constraints.  In the
same way that $C$ and $S$ are phantom types, these are \emph{marker}
traits with no computational value. The typing for
the first example is:
\begin{verbatim}
  (cx: &mut JSContext<S>) where
    S: CanAlloc + InCompartment<C>,
    C: Compartment,
\end{verbatim}
and for the second:
\begin{verbatim}
  (cx: &JSContext<S>) where
    S: CanAccess,
    C: Compartment,
\end{verbatim}
A program to mutably access a JS-managed reference is:
\begin{verbatim}
  let msg: &mut String = x.borrow_mut(cx);
\end{verbatim}
at which point the fact that the JS context is an affine capability
becomes important. The typing required for this is:
\begin{verbatim}
  (cx: &mut JSContext<S>) where
    S: CanAccess,
    C: Compartment,
\end{verbatim}
That is \emph{unique access to JS-managed data requires unique access to th4e JS context},
and so we cannot simultaneously have mutable access to two different JS-managed
references. This is the same safety condition that region-based $L^3$ uses.

For example, we can use this (together with Rust's built-in replace function
which swaps the contents of a mutable reference) to replace the contents of a cell
with a new value:
\begin{verbatim}
  fn replace<S>(self, cx: &'a mut JSContext<S>, new_data: String) -> String where
    S: CanAccess,
    C: Compartment,
  {
    let ref mut old_data = self.0.borrow_mut(cx).data;
    replace(old_data, new_data)
  }
\end{verbatim}
